use std::{fs, process::exit};

mod common;
mod grammar;
mod runtime;

use clap::Parser;

use crate::{grammar::lexer::Lexer, runtime::interpreter::Interpreter};

type AnaParser = grammar::parser::Parser;

#[derive(clap::Parser, Debug)]
#[command(about, long_about = None)]
struct Args {
    /// Print the current ANA version.
    #[arg(short, long, default_value_t = false)]
    version: bool,

    /// Show the tokens generated by the lexer.
    #[arg(short, long, default_value_t = false)]
    tokens: bool,

    /// Show the nodes generated by the parser.
    #[arg(short, long, default_value_t = false)]
    nodes: bool,

    rem: Vec<String>,
}

fn exit_with_msg(msg: String) -> ! {
    println!("{}", msg);
    exit(1)
}

fn main() {
    let args = Args::parse();

    if args.version {
        println!("ANA version {}", runtime::ANA_VERSION);
        return;
    }

    if args.rem.len() == 0 {
        exit_with_msg(String::from("no input file"));
    }

    let text = match fs::read_to_string(&args.rem[0]) {
        Ok(v) => v,
        Err(e) => {
            exit_with_msg(e.to_string());
        }
    };

    let mut lexer = Lexer::new(&text);

    let tokens = match lexer.lex() {
        Ok(v) => v,
        Err(e) => {
            exit_with_msg(e.to_string());
        }
    };

    if args.tokens {
        println!("{:?}", tokens);
    }

    let mut parser = AnaParser::new(tokens);

    let nodes = match parser.parse() {
        Ok(v) => v,
        Err(e) => {
            exit_with_msg(e.to_string());
        }
    };

    if args.nodes {
        println!("nodes:");

        for (i, node) in nodes.iter().enumerate() {
            println!(" {}: {:?}", i, node);
        }
    }

    let mut intrp = Interpreter::new();

    if let Err(e) = intrp.execute(nodes) {
        exit_with_msg(e.to_string());
    }
}
